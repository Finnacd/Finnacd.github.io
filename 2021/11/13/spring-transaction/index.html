
<!DOCTYPE html>
<html lang="zh-cn,en,default">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="ZCGR">
    <title>Spring事务原理 - ZCGR</title>
    <meta name="author" content="Kevin">
    
        <meta name="keywords" content="hexo,ZCGR,zcgr.xyz,spring事务">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="../../../../atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kevin","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"articleBody":"\n\n概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。\n\n\n事务是一个比较广泛的概念，事务管理资源除了我们熟知的数据库外，还可以包含消息队列、文件系统等。当然，一般来说，我们说的事务单指“数据库事务”。接下来我们会以MySQL数据库、Spring声明式事务为主要研究对象，但是很多事务概念、接口抽象和实现方式同时适用于其他情况。\n事务属性和行为ACID属性\n提到事务，不可避免需要涉及到事务的ACID属性：\n\n原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。\n隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。\n\n我们将严格遵循ACID属性的事务称为刚性事务。与之相对，期望最终一致性，在事务执行的中间状态允许暂时不遵循ACID属性的事务称为柔性事务，可参考传统事务与柔性事务，柔性事务的使用涉及到分布式事务方案，可以后续扩展，这里我们先将注意集中在事务实现原理上。\n隔离级别\n根据SQL92标准，MySQL的InnoDB引擎提供四种隔离级别（即ACID中的I）：读未提交（READ UNCOMMITTED）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和串行化（SERIALIZABLE），InnoDB默认的隔离级别是REPEATABLE READ，其可避免脏读和不可重复读，但不能避免幻读，需要指出的是，InnoDB引擎的多版本并发控制机制（MVCC）并没有完全避免幻读，关于该问题以及隔离级别说明，可参考MySQL的InnoDB的幻读问题。\n传播机制\nSpring针对方法嵌套调用时事务的创建行为定义了七种事务传播机制，分别是PROPAGATION_REQUIRED、PROPAGATION_SUPPORT、PROPAGATION_MANDATORY、PROPAGATION_REQUIRES_NEW、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER以及PROPAGATION_NESTED，基本上从字面意思就能知道每种传播机制各自的行为表现，Spring默认的事务传播机制是PROPAGATION_REQUIRED，即如果当前存在事务，则使用当前事务，否则创建新的事务。详情可参考Spring事务传播行为。\n事务行为\n事务的行为包括事务开启、事务提交和事务回滚。InnoDB所有的用户SQL执行都在事务控制之内，在默认情况下，autocommit设置为true，单条SQL执行成功后，MySQL会自动提交事务，或者如果SQL执行出错，则根据异常类型执行事务提交或者回滚。可以使用START TRANSACTION（SQL标准）或者BEGIN开启事务，使用COMMIT和ROLLBACK提交和回滚事务；也可以通过设置autocommit属性来控制事务行为，当设置autocommit为false时，其后执行的多条SQL语句将在一个事务内，直到执行COMMIT或者ROLLBACK事务才会提交或者回滚。\nAOP增强Spring使用AOP（面向切面编程）来实现声明式事务，后续在讲Spring事务具体实现的时候会详细说明，关于AOP的概念可参考Spring AOP概念理解（通俗易懂），这里不再细说。说下动态代理和AOP增强。\n动态代理是Spring实现AOP的默认方式，分为两种：JDK动态代理和CGLIB动态代理。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者objenesis类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。\n我们在切面配置中会使用到@Aspect注解，这里用到了Aspectj的切面表达式。Aspectj是java语言实现的一个AOP框架，使用静态代理模式，拥有完善的AOP功能，与Spring AOP互为补充。Spring采用了Aspectj强大的切面表达式定义方式，但是默认情况下仍然使用动态代理方式，并未使用Aspectj的编译器和织入器，当然也支持配置使用Aspectj静态代理替代动态代理方式。Aspectj功能更强大，比方说它支持对字段、POJO类进行增强，与之相对，Spring只支持对Bean方法级别进行增强。\nSpring对方法的增强有五种方式：\n\n前置增强（org.springframework.aop.BeforeAdvice）：在目标方法执行之前进行增强；\n后置增强（org.springframework.aop.AfterReturningAdvice）：在目标方法执行之后进行增强；\n环绕增强（org.aopalliance.intercept.MethodInterceptor）：在目标方法执行前后都执行增强；\n异常抛出增强（org.springframework.aop.ThrowsAdvice）：在目标方法抛出异常后执行增强；\n引介增强（org.springframework.aop.IntroductionInterceptor）：为目标类添加新的方法和属性。\n\n声明式事务的实现就是通过环绕增强的方式，在目标方法执行之前开启事务，在目标方法执行之后提交或者回滚事务，事务拦截器的继承关系图可以体现这一点：\n\nSpring事务抽象统一一致的事务抽象是Spring框架的一大优势，无论是全局事务还是本地事务，JTA、JDBC、Hibernate还是JPA，Spring都使用统一的编程模型，使得应用程序可以很容易地在全局事务与本地事务，或者不同的事务框架之间进行切换。下图是Spring事务抽象的核心类图：\n\n接口PlatformTransactionManager定义了事务操作的行为，其依赖TransactionDefinition和TransactionStatus接口，其实大部分的事务属性和行为我们以MySQL数据库为例已经有过了解，这里再对应介绍下。\n\nPlatformTransactionManager：事务管理器\ngetTransaction方法：事务获取操作，根据事务属性定义，获取当前事务或者创建新事物；\ncommit方法：事务提交操作，注意这里所说的提交并非直接提交事务，而是根据当前事务状态执行提交或者回滚操作；\nrollback方法：事务回滚操作，同样，也并非一定直接回滚事务，也有可能只是标记事务为只读，等待其他调用方执行回滚。\nTransactionDefinition：事务属性定义\ngetPropagationBehavior方法：返回事务的传播属性，默认是PROPAGATION_REQUIRED；\ngetIsolationLevel方法：返回事务隔离级别，事务隔离级别只有在创建新事务时才有效，也就是说只对应传播属性PROPAGATION_REQUIRED和PROPAGATION_REQUIRES_NEW；\ngetTimeout方法：返回事务超时时间，以秒为单位，同样只有在创建新事务时才有效；\nisReadOnly方法：是否优化为只读事务，支持这项属性的事务管理器会将事务标记为只读，只读事务不允许有写操作，不支持只读属性的事务管理器需要忽略这项设置，这一点跟其他事务属性定义不同，针对其他不支持的属性设置，事务管理器应该抛出异常。\ngetName方法：返回事务名称，声明式事务中默认值为“类的完全限定名.方法名”。\nTransactionStatus：当前事务状态\nisNewTransaction方法：当前方法是否创建了新事务（区别于使用现有事务以及没有事务）；\nhasSavepoint方法：在嵌套事务场景中，判断当前事务是否包含保存点；\nsetRollbackOnly和isRollbackOnly方法：只读属性设置（主要用于标记事务，等待回滚）和查询；\nflush方法：刷新底层会话中的修改到数据库，一般用于刷新如Hibernate/JPA的会话，是否生效由具体事务资源实现决定；\nisCompleted方法：判断当前事务是否已完成（已提交或者已回滚）。\n\n部分Spring包含的对PlatformTransactionManager的实现类如下图所示：\n\nAbstractPlatformTransactionManager抽象类实现了Spring事务的标准流程，其子类DataSourceTransactionManager是我们使用较多的JDBC单数据源事务管理器，而JtaTransactionManager是JTA（Java Transaction API）规范的实现类，另外两个则分别是JavaEE容器WebLogic和WebSphere的JTA事务管理器的具体实现。\nSpring事务切面之前提到，Spring采用AOP来实现声明式事务，那么事务的AOP切面是如何织入的呢？这一点涉及到AOP动态代理对象的生成过程。\n代理对象生成的核心类是AbstractAutoProxyCreator，实现了BeanPostProcessor接口，会在Bean初始化完成之后，通过postProcessAfterInitialization方法生成代理对象，关于BeanPostProcessor在Bean生命周期中的作用，可参考一些常用的Spring扩展接口。\n看一下AbstractAutoProxyCreator类的核心代码，主要关注三个方法：postProcessAfterInitialization、wrapIfNecessary和createProxy，为了突出核心流程，以注释代替了部分代码的具体实现，后续的源码分析也采用相同的处理。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// AbstractAutoProxyCreator.class@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;    if (bean != null) &#123;        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (!this.earlyProxyReferences.contains(cacheKey)) &#123;            // 创建代理对象            return wrapIfNecessary(bean, beanName, cacheKey);        &#125;    &#125;    return bean;&#125;protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123;    // 参数检查，跳过已经执行过代理对象生成，或者已知的不需要生成代理对象的Bean    ...    // Create proxy if we have advice.    // 查询当前Bean所有的AOP增强配置，最终是通过AOPUtils工具类实现    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);    if (specificInterceptors != DO_NOT_PROXY) &#123;        this.advisedBeans.put(cacheKey, Boolean.TRUE);        // 执行AOP织入，创建代理对象        Object proxy = createProxy(                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    &#125;    this.advisedBeans.put(cacheKey, Boolean.FALSE);    return bean;&#125;protected Object createProxy(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;    if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);    &#125;    // 实例化代理工厂类    ProxyFactory proxyFactory = new ProxyFactory();    proxyFactory.copyFrom(this);    // 当全局使用动态代理时，设置是否需要对目标Bean强制使用CGLIB动态代理    ...    // 构建AOP增强顾问，包含框架公共增强和应用程序自定义增强    // 设置proxyFactory属性，如增强、目标类、是否允许变更等    ...    // 创建代理对象    return proxyFactory.getProxy(getProxyClassLoader());&#125;\n\n最后是通过调用ProxyFactory#getProxy(java.lang.ClassLoader)方法来创建代理对象：\n12345678910111213141516// ProxyFactory.classpublic Object getProxy(ClassLoader classLoader) &#123;    return createAopProxy().getProxy(classLoader);&#125;// ProxyFactory父类ProxyCreatorSupport.classprotected final synchronized AopProxy createAopProxy() &#123;    if (!this.active) &#123;        activate();    &#125;    return getAopProxyFactory().createAopProxy(this);&#125;public ProxyCreatorSupport() &#123;    this.aopProxyFactory = new DefaultAopProxyFactory();&#125;\n\nProxyFactory的父类构造器实例化了DefaultAopProxyFactory类，从其源代码我们可以看到Spring动态代理方式选择策略的实现：如果目标类optimize，proxyTargetClass属性设置为true或者未指定需要代理的接口，则使用CGLIB生成代理对象，否则使用JDK动态代理。\n1234567891011121314151617181920212223public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;    @Override    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;        // 如果optimize，proxyTargetClass属性设置为true或者未指定代理接口，则使用CGLIB生成代理对象        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;            Class&lt;?&gt; targetClass = config.getTargetClass();            // 参数检查，targetClass为空抛出异常            ...            // 目标类本身是接口或者代理对象，仍然使用JDK动态代理            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;                return new JdkDynamicAopProxy(config);            &#125;            // Objenesis是一个可以不通过构造器创建子类的java工具类库            // 作为Spring 4.0后CGLIB的默认实现            return new ObjenesisCglibAopProxy(config);        &#125;        else &#123;            // 否则使用JDK动态代理            return new JdkDynamicAopProxy(config);        &#125;    &#125;    ...&#125;\n\nSpring事务拦截我们已经了解了AOP切面织入生成代理对象的过程，当Bean方法通过代理对象调用时，会触发对应的AOP增强拦截器，前面提到声明式事务是一种环绕增强，对应接口为MethodInterceptor，事务增强对该接口的实现为TransactionInterceptor，类图如下：\n\n事务拦截器TransactionInterceptor在invoke方法中，通过调用父类TransactionAspectSupport的invokeWithinTransaction方法进行事务处理，该方法支持声明式事务和编程式事务。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// TransactionInterceptor.class@Overridepublic Object invoke(final MethodInvocation invocation) throws Throwable &#123;    // 获取targetClass    ...    // Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...    return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123;        @Override        public Object proceedWithInvocation() throws Throwable &#123;            // 实际执行目标方法            return invocation.proceed();        &#125;    &#125;);&#125;// TransactionInterceptor父类TransactionAspectSupport.classprotected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)        throws Throwable &#123;    // If the transaction attribute is null, the method is non-transactional.    // 查询目标方法事务属性、确定事务管理器、构造连接点标识（用于确认事务名称）    final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);    final PlatformTransactionManager tm = determineTransactionManager(txAttr);    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123;        // 事务获取        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);        Object retVal = null;        try &#123;            // 通过回调执行目标方法            retVal = invocation.proceedWithInvocation();        &#125;        catch (Throwable ex) &#123;            // 目标方法执行抛出异常，根据异常类型执行事务提交或者回滚操作            completeTransactionAfterThrowing(txInfo, ex);            throw ex;        &#125;        finally &#123;            // 清理当前线程事务信息            cleanupTransactionInfo(txInfo);        &#125;        // 目标方法执行成功，提交事务        commitTransactionAfterReturning(txInfo);        return retVal;    &#125; else &#123;        // 带回调的事务执行处理，一般用于编程式事务        ...    &#125;&#125;\n\n在讲Spring事务抽象时，有提到事务抽象的核心接口为PlatformTransactionManager，它负责管理事务行为，包括事务的获取、提交和回滚。在invokeWithinTransaction方法中，我们可以看到createTransactionIfNecessary、commitTransactionAfterReturning和completeTransactionAfterThrowing都是针对该接口编程，并不依赖于特定事务管理器，这里是对Spring事务抽象的实现。\n12345678910111213141516171819202122232425262728293031323334353637383940//TransactionAspectSupport.classprotected TransactionInfo createTransactionIfNecessary(        PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) &#123;    ...    TransactionStatus status = null;    if (txAttr != null) &#123;        if (tm != null) &#123;            // 获取事务            status = tm.getTransaction(txAttr);            ...&#125;protected void commitTransactionAfterReturning(TransactionInfo txInfo) &#123;    if (txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;        ...        // 提交事务        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());    &#125;&#125;protected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) &#123;    if (txInfo != null &amp;&amp; txInfo.hasTransaction()) &#123;        ...        if (txInfo.transactionAttribute.rollbackOn(ex)) &#123;            try &#123;                // 异常类型为回滚异常，执行事务回滚                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());            &#125;            ...        &#125; else &#123;            try &#123;                // 异常类型为非回滚异常，仍然执行事务提交                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());            &#125;            ...&#125;protected final class TransactionInfo &#123;    private final PlatformTransactionManager transactionManager;    ...\n\n另外，在获取事务时，AbstractPlatformTransactionManager#doBegin方法负责开启新事务，在DataSourceTransactionManager有如下代码：\n12345678910111213@Overrideprotected void doBegin(Object transaction, TransactionDefinition definition) &#123;    // 获取数据库连接con    ...    if (con.getAutoCommit()) &#123;        txObject.setMustRestoreAutoCommit(true);        if (logger.isDebugEnabled()) &#123;            logger.debug(&quot;Switching JDBC Connection [&quot; + con + &quot;] to manual commit&quot;);        &#125;        con.setAutoCommit(false);    &#125;    ...&#125;\n\n这里才真正开启了数据库事务。\nSpring事务同步提到事务传播机制时，我们经常提到一个条件“如果当前已有事务”，那么Spring是如何知道当前是否已经开启了事务呢？在AbstractPlatformTransactionManager中是这样做的：\n12345678910111213141516171819// AbstractPlatformTransactionManager.class@Overridepublic final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException &#123;    Object transaction = doGetTransaction();    // 参数为null时构造默认值    ...    if (isExistingTransaction(transaction)) &#123;        // Existing transaction found -&gt; check propagation behavior to find out how to behave.        return handleExistingTransaction(definition, transaction, debugEnabled);    &#125;    ...// 获取当前事务对象protected abstract Object doGetTransaction() throws TransactionException;// 判断当前事务对象是否包含活跃事务protected boolean isExistingTransaction(Object transaction) throws TransactionException &#123;    return false;&#125;\n\n注意getTransaction方法是final的，无法被子类覆盖，保证了获取事务流程的一致和稳定。抽象方法doGetTransaction获取当前事务对象，方法isExistingTransaction判断当前事务对象是否存在活跃事务，具体逻辑由特定事务管理器实现，看下我们使用最多的DataSourceTransactionManager对应的实现：\n12345678910111213141516// DataSourceTransactionManager.class@Overrideprotected Object doGetTransaction() &#123;    DataSourceTransactionObject txObject = new DataSourceTransactionObject();    txObject.setSavepointAllowed(isNestedTransactionAllowed());    ConnectionHolder conHolder =            (ConnectionHolder) TransactionSynchronizationManager.getResource(this.dataSource);    txObject.setConnectionHolder(conHolder, false);    return txObject;&#125;@Overrideprotected boolean isExistingTransaction(Object transaction) &#123;    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;    return (txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive());&#125;\n\n可以看到，获取当前事务对象时，使用了TransactionSynchronizationManager#getResource方法，类图如下：\n\nTransactionSynchronizationManager通过ThreadLocal对象在当前线程记录了resources和synchronizations属性。resources是一个HashMap，用于记录当前参与事务的事务资源，方便进行事务同步，在DataSourceTransactionManager的例子中就是以dataSource作为key，保存了数据库连接，这样在同一个线程中，不同的方法调用就可以通过dataSource获取相同的数据库连接，从而保证所有操作在一个事务中进行。synchronizations属性是一个TransactionSynchronization对象的集合，AbstractPlatformTransactionManager类中定义了事务操作各个阶段的调用流程，以事务提交为例：\n12345678910111213141516171819202122232425// AbstractPlatformTransactionManager.classprivate void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;    try &#123;        boolean beforeCompletionInvoked = false;        try &#123;            prepareForCommit(status);            triggerBeforeCommit(status);            triggerBeforeCompletion(status);            ....            else if (status.isNewTransaction()) &#123;                // 记录日志                ...                doCommit(status);            &#125;            ...        // 事务调用异常处理        ...        try &#123;            triggerAfterCommit(status);        &#125;        finally &#123;            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);        &#125;    &#125;&#125;\n\n我们可以看到，有很多trigger前缀的方法，这些方法用于在事务操作的各个阶段触发回调，从而可以精确控制在事务执行的不同阶段所要执行的操作，这些回调实际上都通过TransactionSynchronizationUtils来实现，它会遍历TransactionSynchronizationManager#synchronizations集合中的TransactionSynchronization对象，然后分别触发集合中各个元素对应方法的调用。例如：\n123456TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() &#123;    @Override    public void afterCommit() &#123;        // do something after commit    &#125;&#125;);\n\n这段代码就在当前线程的事务synchronizations属性中，添加了一个自定义同步类，如果当前存在事务，那么在事务管理器执行事务提交之后，就会触发afterCommit方法，可以通过这种方式在事务执行的不同阶段自定义一些操作。\n","dateCreated":"2021-11-13T21:15:50+08:00","dateModified":"2021-11-13T21:27:05+08:00","datePublished":"2021-11-13T21:15:50+08:00","description":"\n\n概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。","headline":"Spring事务原理","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"../../../../http:/localhost:4000/2021/11/13/spring-transaction/"},"publisher":{"@type":"Organization","name":"Kevin","sameAs":["https://github.com/","http://stackoverflow.com/users","https://twitter.com/","https://facebook.com/","https://plus.google.com/","https://www.linkedin.com/profile/","mailto"]},"url":"../../../../http:/localhost:4000/2021/11/13/spring-transaction/","keywords":"spring, spring事务"}</script>
    <meta name="description" content="概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。">
<meta property="og:type" content="blog">
<meta property="og:title" content="Spring事务原理">
<meta property="og:url" content="http://localhost:4000/2021/11/13/spring-transaction/index.html">
<meta property="og:site_name" content="ZCGR">
<meta property="og:description" content="概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://localhost:4000/2021/11/13/spring-transaction/1.png">
<meta property="og:image" content="http://localhost:4000/2021/11/13/spring-transaction/2.png">
<meta property="og:image" content="http://localhost:4000/2021/11/13/spring-transaction/3.png">
<meta property="og:image" content="http://localhost:4000/2021/11/13/spring-transaction/4.png">
<meta property="og:image" content="http://localhost:4000/2021/11/13/spring-transaction/5.png">
<meta property="article:published_time" content="2021-11-13T13:15:50.000Z">
<meta property="article:modified_time" content="2021-11-13T13:27:05.140Z">
<meta property="article:author" content="Kevin">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="spring事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://localhost:4000/2021/11/13/spring-transaction/1.png">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="../../../../assets/css/all.css">

    
<link rel="stylesheet" href="../../../../assets/css/jquery.fancybox.css">

    
<link rel="stylesheet" href="../../../../assets/css/thumbs.css">

    
<link rel="stylesheet" href="../../../../assets/css/tranquilpeak.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="../../../../index.html"
            aria-label=""
        >
            ZCGR
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="../../../../#about"
                aria-label="打开链接: ../../../../#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../index.html"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="../../../../#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../https:/github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../http:/stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../https:/twitter.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../https:/facebook.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../https:/plus.google.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google Plus"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Plus</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../https:/www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../mailto"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="../../../../atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            Spring事务原理
        </h1>
    
    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E5%92%8C%E8%A1%8C%E4%B8%BA"><span class="toc-text">事务属性和行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E5%A2%9E%E5%BC%BA"><span class="toc-text">AOP增强</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E6%8A%BD%E8%B1%A1"><span class="toc-text">Spring事务抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%88%87%E9%9D%A2"><span class="toc-text">Spring事务切面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E6%8B%A6%E6%88%AA"><span class="toc-text">Spring事务拦截</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-text">Spring事务同步</span></a></li></ol>

<p>概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。</p>
<span id="more"></span>

<p>事务是一个比较广泛的概念，事务管理资源除了我们熟知的数据库外，还可以包含消息队列、文件系统等。当然，一般来说，我们说的事务单指“数据库事务”。接下来我们会以MySQL数据库、Spring声明式事务为主要研究对象，但是很多事务概念、接口抽象和实现方式同时适用于其他情况。</p>
<h2 id="事务属性和行为"><a href="#事务属性和行为" class="headerlink" title="事务属性和行为"></a><strong>事务属性和行为</strong></h2><p><strong>ACID属性</strong></p>
<p>提到事务，不可避免需要涉及到事务的ACID属性：</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。</li>
</ul>
<p>我们将严格遵循ACID属性的事务称为<strong>刚性事务</strong>。与之相对，期望最终一致性，在事务执行的中间状态允许暂时不遵循ACID属性的事务称为<strong>柔性事务</strong>，可参考<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/ab1a1c6b08a1">传统事务与柔性事务</a>，柔性事务的使用涉及到<strong>分布式事务</strong>方案，可以后续扩展，这里我们先将注意集中在事务实现原理上。</p>
<p><strong>隔离级别</strong></p>
<p>根据SQL92标准，MySQL的InnoDB引擎提供四种<strong>隔离级别</strong>（即ACID中的I）：读未提交（READ UNCOMMITTED）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）和串行化（SERIALIZABLE），InnoDB默认的隔离级别是<code>REPEATABLE READ</code>，其可避免<em>脏读</em>和<em>不可重复读</em>，但不能避免<em>幻读</em>，需要指出的是，InnoDB引擎的多版本并发控制机制（MVCC）并没有完全避免<em>幻读</em>，关于该问题以及隔离级别说明，可参考<a href="https://link.zhihu.com/?target=http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a>。</p>
<p><strong>传播机制</strong></p>
<p>Spring针对方法嵌套调用时事务的创建行为定义了七种<strong>事务传播机制</strong>，分别是PROPAGATION_REQUIRED、PROPAGATION_SUPPORT、PROPAGATION_MANDATORY、PROPAGATION_REQUIRES_NEW、PROPAGATION_NOT_SUPPORTED、PROPAGATION_NEVER以及PROPAGATION_NESTED，基本上从字面意思就能知道每种传播机制各自的行为表现，Spring默认的事务传播机制是<code>PROPAGATION_REQUIRED</code>，即如果当前存在事务，则使用当前事务，否则创建新的事务。详情可参考<a href="https://link.zhihu.com/?target=https://juejin.im/post/5ae9639af265da0b926564e7">Spring事务传播行为</a>。</p>
<p><strong>事务行为</strong></p>
<p>事务的行为包括事务开启、事务提交和事务回滚。InnoDB所有的用户SQL执行都在事务控制之内，在默认情况下，<strong>autocommit</strong>设置为<code>true</code>，单条SQL执行成功后，MySQL会自动提交事务，或者如果SQL执行出错，则根据异常类型执行事务提交或者回滚。可以使用<code>START TRANSACTION</code>（SQL标准）或者<code>BEGIN</code>开启事务，使用<code>COMMIT</code>和<code>ROLLBACK</code>提交和回滚事务；也可以通过设置autocommit属性来控制事务行为，当设置autocommit为<code>false</code>时，其后执行的多条SQL语句将在一个事务内，直到执行<code>COMMIT</code>或者<code>ROLLBACK</code>事务才会提交或者回滚。</p>
<h2 id="AOP增强"><a href="#AOP增强" class="headerlink" title="AOP增强"></a><strong>AOP增强</strong></h2><p>Spring使用<strong>AOP</strong>（面向切面编程）来实现<strong>声明式事务</strong>，后续在讲Spring事务具体实现的时候会详细说明，关于AOP的概念可参考<a href="https://link.zhihu.com/?target=https://blog.csdn.net/qukaiwei/article/details/50367761">Spring AOP概念理解（通俗易懂）</a>，这里不再细说。说下<strong>动态代理</strong>和<strong>AOP增强</strong>。</p>
<p>动态代理是Spring实现AOP的默认方式，分为两种：<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。JDK动态代理面向接口，通过反射生成目标代理接口的匿名实现类；CGLIB动态代理则通过继承，使用字节码增强技术（或者<code>objenesis</code>类库）为目标代理类生成代理子类。Spring默认对接口实现使用JDK动态代理，对具体类使用CGLIB，同时也支持配置全局使用CGLIB来生成代理对象。</p>
<p>我们在切面配置中会使用到<code>@Aspect</code>注解，这里用到了<strong>Aspectj</strong>的切面表达式。Aspectj是java语言实现的一个AOP框架，使用静态代理模式，拥有完善的AOP功能，与Spring AOP互为补充。Spring采用了Aspectj强大的切面表达式定义方式，但是默认情况下仍然使用动态代理方式，并未使用Aspectj的编译器和织入器，当然也支持配置使用Aspectj静态代理替代动态代理方式。Aspectj功能更强大，比方说它支持对字段、POJO类进行增强，与之相对，Spring只支持对Bean方法级别进行增强。</p>
<p>Spring对方法的增强有五种方式：</p>
<ul>
<li>前置增强（<code>org.springframework.aop.BeforeAdvice</code>）：在目标方法执行之前进行增强；</li>
<li>后置增强（<code>org.springframework.aop.AfterReturningAdvice</code>）：在目标方法执行之后进行增强；</li>
<li>环绕增强（<code>org.aopalliance.intercept.MethodInterceptor</code>）：在目标方法执行前后都执行增强；</li>
<li>异常抛出增强（<code>org.springframework.aop.ThrowsAdvice</code>）：在目标方法抛出异常后执行增强；</li>
<li>引介增强（<code>org.springframework.aop.IntroductionInterceptor</code>）：为目标类添加新的方法和属性。</li>
</ul>
<p>声明式事务的实现就是通过环绕增强的方式，在目标方法执行之前开启事务，在目标方法执行之后提交或者回滚事务，事务拦截器的继承关系图可以体现这一点：</p>
<p><img src="/2021/11/13/spring-transaction/1.png" alt="img"></p>
<h2 id="Spring事务抽象"><a href="#Spring事务抽象" class="headerlink" title="Spring事务抽象"></a>Spring事务抽象</h2><p>统一一致的事务抽象是Spring框架的一大优势，无论是全局事务还是本地事务，JTA、JDBC、Hibernate还是JPA，Spring都使用统一的编程模型，使得应用程序可以很容易地在全局事务与本地事务，或者不同的事务框架之间进行切换。下图是Spring事务抽象的核心类图：</p>
<p><img src="/2021/11/13/spring-transaction/2.png" alt="img"></p>
<p>接口<code>PlatformTransactionManager</code>定义了事务操作的行为，其依赖<code>TransactionDefinition</code>和<code>TransactionStatus</code>接口，其实大部分的事务属性和行为我们以MySQL数据库为例已经有过了解，这里再对应介绍下。</p>
<ul>
<li><code>PlatformTransactionManager</code>：事务管理器</li>
<li><code>getTransaction</code>方法：事务获取操作，根据事务属性定义，获取当前事务或者创建新事物；</li>
<li><code>commit</code>方法：事务提交操作，注意这里所说的提交并非直接提交事务，而是根据当前事务状态执行提交或者回滚操作；</li>
<li><code>rollback</code>方法：事务回滚操作，同样，也并非一定直接回滚事务，也有可能只是标记事务为只读，等待其他调用方执行回滚。</li>
<li><code>TransactionDefinition</code>：事务属性定义</li>
<li><code>getPropagationBehavior</code>方法：返回事务的传播属性，默认是<code>PROPAGATION_REQUIRED</code>；</li>
<li><code>getIsolationLevel</code>方法：返回事务隔离级别，事务隔离级别只有在创建新事务时才有效，也就是说只对应传播属性<code>PROPAGATION_REQUIRED</code>和<code>PROPAGATION_REQUIRES_NEW</code>；</li>
<li><code>getTimeout</code>方法：返回事务超时时间，以秒为单位，同样只有在创建新事务时才有效；</li>
<li><code>isReadOnly</code>方法：是否优化为只读事务，支持这项属性的事务管理器会将事务标记为只读，只读事务不允许有写操作，不支持只读属性的事务管理器需要忽略这项设置，这一点跟其他事务属性定义不同，针对其他不支持的属性设置，事务管理器应该抛出异常。</li>
<li><code>getName</code>方法：返回事务名称，声明式事务中默认值为“类的完全限定名.方法名”。</li>
<li><code>TransactionStatus</code>：当前事务状态</li>
<li><code>isNewTransaction</code>方法：当前方法是否创建了新事务（区别于使用现有事务以及没有事务）；</li>
<li><code>hasSavepoint</code>方法：在嵌套事务场景中，判断当前事务是否包含保存点；</li>
<li><code>setRollbackOnly</code>和<code>isRollbackOnly</code>方法：只读属性设置（主要用于标记事务，等待回滚）和查询；</li>
<li><code>flush</code>方法：刷新底层会话中的修改到数据库，一般用于刷新如Hibernate/JPA的会话，是否生效由具体事务资源实现决定；</li>
<li><code>isCompleted</code>方法：判断当前事务是否已完成（已提交或者已回滚）。</li>
</ul>
<p>部分Spring包含的对<code>PlatformTransactionManager</code>的实现类如下图所示：</p>
<p><img src="/2021/11/13/spring-transaction/3.png" alt="img"></p>
<p><code>AbstractPlatformTransactionManager</code>抽象类实现了Spring事务的标准流程，其子类<code>DataSourceTransactionManager</code>是我们使用较多的JDBC单数据源事务管理器，而<code>JtaTransactionManager</code>是JTA（Java Transaction API）规范的实现类，另外两个则分别是JavaEE容器<em>WebLogic</em>和<em>WebSphere</em>的JTA事务管理器的具体实现。</p>
<h2 id="Spring事务切面"><a href="#Spring事务切面" class="headerlink" title="Spring事务切面"></a>Spring事务切面</h2><p>之前提到，Spring采用AOP来实现声明式事务，那么事务的AOP切面是如何织入的呢？这一点涉及到AOP动态代理对象的生成过程。</p>
<p>代理对象生成的核心类是<code>AbstractAutoProxyCreator</code>，实现了<code>BeanPostProcessor</code>接口，会在<strong>Bean初始化完成之后</strong>，通过<code>postProcessAfterInitialization</code>方法生成代理对象，关于<code>BeanPostProcessor</code>在Bean生命周期中的作用，可参考<a href="https://link.zhihu.com/?target=https://www.cnblogs.com/xrq730/p/5721366.html">一些常用的Spring扩展接口</a>。</p>
<p>看一下<code>AbstractAutoProxyCreator</code>类的核心代码，主要关注三个方法：postProcessAfterInitialization、wrapIfNecessary和createProxy，为了突出核心流程，以注释代替了部分代码的具体实现，后续的源码分析也采用相同的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数检查，跳过已经执行过代理对象生成，或者已知的不需要生成代理对象的Bean</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 查询当前Bean所有的AOP增强配置，最终是通过AOPUtils工具类实现</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 执行AOP织入，创建代理对象</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化代理工厂类</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当全局使用动态代理时，设置是否需要对目标Bean强制使用CGLIB动态代理</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建AOP增强顾问，包含框架公共增强和应用程序自定义增强</span></span><br><span class="line">    <span class="comment">// 设置proxyFactory属性，如增强、目标类、是否允许变更等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是通过调用<code>ProxyFactory#getProxy(java.lang.ClassLoader)</code>方法来创建代理对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyFactory.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProxyFactory父类ProxyCreatorSupport.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ProxyCreatorSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aopProxyFactory = <span class="keyword">new</span> DefaultAopProxyFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProxyFactory</code>的父类构造器实例化了<code>DefaultAopProxyFactory</code>类，从其源代码我们可以看到Spring动态代理方式选择策略的实现：如果目标类optimize，proxyTargetClass属性设置为<code>true</code>或者未指定需要代理的接口，则使用CGLIB生成代理对象，否则使用JDK动态代理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果optimize，proxyTargetClass属性设置为true或者未指定代理接口，则使用CGLIB生成代理对象</span></span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="comment">// 参数检查，targetClass为空抛出异常</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 目标类本身是接口或者代理对象，仍然使用JDK动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Objenesis是一个可以不通过构造器创建子类的java工具类库</span></span><br><span class="line">            <span class="comment">// 作为Spring 4.0后CGLIB的默认实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则使用JDK动态代理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring事务拦截"><a href="#Spring事务拦截" class="headerlink" title="Spring事务拦截"></a>Spring事务拦截</h2><p>我们已经了解了AOP切面织入生成代理对象的过程，当Bean方法通过代理对象调用时，会触发对应的AOP增强拦截器，前面提到声明式事务是一种环绕增强，对应接口为<code>MethodInterceptor</code>，事务增强对该接口的实现为<code>TransactionInterceptor</code>，类图如下：</p>
<p><img src="/2021/11/13/spring-transaction/4.png" alt="img"></p>
<p>事务拦截器<code>TransactionInterceptor</code>在<code>invoke</code>方法中，通过调用父类<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法进行事务处理，该方法支持声明式事务和编程式事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionInterceptor.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 获取targetClass</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> InvocationCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 实际执行目标方法</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TransactionInterceptor父类TransactionAspectSupport.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    <span class="comment">// 查询目标方法事务属性、确定事务管理器、构造连接点标识（用于确认事务名称）</span></span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// 事务获取</span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        Object retVal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过回调执行目标方法</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 目标方法执行抛出异常，根据异常类型执行事务提交或者回滚操作</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清理当前线程事务信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标方法执行成功，提交事务</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 带回调的事务执行处理，一般用于编程式事务</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在讲Spring事务抽象时，有提到事务抽象的核心接口为<code>PlatformTransactionManager</code>，它负责管理事务行为，包括事务的获取、提交和回滚。在<code>invokeWithinTransaction</code>方法中，我们可以看到<code>createTransactionIfNecessary</code>、<code>commitTransactionAfterReturning</code>和<code>completeTransactionAfterThrowing</code>都是针对该接口编程，并不依赖于特定事务管理器，这里是对Spring事务抽象的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TransactionAspectSupport.class</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        PlatformTransactionManager tm, TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取事务</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 异常类型为回滚异常，执行事务回滚</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 异常类型为非回滚异常，仍然执行事务提交</span></span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>另外，在获取事务时，<code>AbstractPlatformTransactionManager#doBegin</code>方法负责开启新事务，在<code>DataSourceTransactionManager</code>有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数据库连接con</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">        txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里才真正开启了数据库事务。</p>
<h2 id="Spring事务同步"><a href="#Spring事务同步" class="headerlink" title="Spring事务同步"></a>Spring事务同步</h2><p>提到事务传播机制时，我们经常提到一个条件“如果当前已有事务”，那么Spring是如何知道当前是否已经开启了事务呢？在<code>AbstractPlatformTransactionManager</code>中是这样做的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    Object transaction = doGetTransaction();</span><br><span class="line">    <span class="comment">// 参数为null时构造默认值</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前事务对象</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前事务对象是否包含活跃事务</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExistingTransaction</span><span class="params">(Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>getTransaction</code>方法是<code>final</code>的，无法被子类覆盖，保证了获取事务流程的一致和稳定。抽象方法<code>doGetTransaction</code>获取当前事务对象，方法<code>isExistingTransaction</code>判断当前事务对象是否存在活跃事务，具体逻辑由特定事务管理器实现，看下我们使用最多的<code>DataSourceTransactionManager</code>对应的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(isNestedTransactionAllowed());</span><br><span class="line">    ConnectionHolder conHolder =</span><br><span class="line">            (ConnectionHolder) TransactionSynchronizationManager.getResource(<span class="keyword">this</span>.dataSource);</span><br><span class="line">    txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExistingTransaction</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="keyword">return</span> (txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，获取当前事务对象时，使用了<code>TransactionSynchronizationManager#getResource</code>方法，类图如下：</p>
<p><img src="/2021/11/13/spring-transaction/5.png" alt="img"></p>
<p><code>TransactionSynchronizationManager</code>通过<code>ThreadLocal</code>对象在当前线程记录了<code>resources</code>和<code>synchronizations</code>属性。<code>resources</code>是一个HashMap，用于记录当前参与事务的事务资源，方便进行事务同步，在<code>DataSourceTransactionManager</code>的例子中就是以<code>dataSource</code>作为key，保存了数据库连接，这样在同一个线程中，不同的方法调用就可以通过<code>dataSource</code>获取相同的数据库连接，从而保证所有操作在一个事务中进行。<code>synchronizations</code>属性是一个<code>TransactionSynchronization</code>对象的集合，<code>AbstractPlatformTransactionManager</code>类中定义了事务操作各个阶段的调用流程，以事务提交为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager.class</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prepareForCommit(status);</span><br><span class="line">            triggerBeforeCommit(status);</span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            ....</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                ...</span><br><span class="line">                doCommit(status);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        <span class="comment">// 事务调用异常处理</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerAfterCommit(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，有很多<em>trigger</em>前缀的方法，这些方法用于在事务操作的各个阶段触发回调，从而可以精确控制在事务执行的不同阶段所要执行的操作，这些回调实际上都通过<code>TransactionSynchronizationUtils</code>来实现，它会遍历<code>TransactionSynchronizationManager#synchronizations</code>集合中的<code>TransactionSynchronization</code>对象，然后分别触发集合中各个元素对应方法的调用。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something after commit</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码就在当前线程的事务<code>synchronizations</code>属性中，添加了一个自定义同步类，如果当前存在事务，那么在事务管理器执行事务提交之后，就会触发<code>afterCommit</code>方法，可以通过这种方式在事务执行的不同阶段自定义一些操作。</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="../../../../all-tags/spring/" rel="tag">spring</a> <a class="tag tag--primary tag--small t-none-link" href="../../../../all-tags/spring%E4%BA%8B%E5%8A%A1/" rel="tag">spring事务</a>

            </div>
        
        
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2021 Kevin. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">Kevin</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="../assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://localhost:4000/2021/09/16/The-principle-and-reliability-of-rocketmq-sending-synchronization-message/"
                            aria-label=": RocketMQ发送同步消息原理以及可靠性思考"
                        >
                            <h3 class="media-heading">RocketMQ发送同步消息原理以及可靠性思考</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021年9月16日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><!-- toc -->

<p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://localhost:4000/2021/09/23/Implementation-principle-of-rocketmq-transaction-message/"
                            aria-label=": Rocketmq事务消息实现原理"
                        >
                            <h3 class="media-heading">Rocketmq事务消息实现原理</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021年9月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><!-- topic -->

<p>RocketMQ提供了事务消息的功能，采用2PC(两段式协议)+补偿机制（事务回查）的分布式事务功能，通过消息队列 RocketMQ 版事务消息能达到分布式事务的最终一致。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://localhost:4000/2021/11/10/lambda/"
                            aria-label=": Lambda"
                        >
                            <h3 class="media-heading">Lambda</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021年11月10日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><!-- toc -->

<p>Lambda 表达式是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="http://localhost:4000/2021/11/13/spring-transaction/"
                            aria-label=": Spring事务原理"
                        >
                            <h3 class="media-heading">Spring事务原理</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2021年11月13日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><!-- toc -->

<p>概括来讲，事务是一个由有限操作集合组成的逻辑单元。事务操作包含两个目的，数据一致以及操作隔离。数据一致是指事务提交时保证事务内的所有操作都成功完成，并且更改永久生效；事务回滚时，保证能够恢复到事务执行之前的状态。操作隔离则是指多个同时执行的事务之间应该相互独立，互不影响。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 4 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('../../../../assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="../../../../assets/js/jquery.js"></script>


<script src="../../../../assets/js/jquery.fancybox.js"></script>


<script src="../../../../assets/js/thumbs.js"></script>


<script src="../../../../assets/js/tranquilpeak.js"></script>

<!--SCRIPTS END-->




    
<script src="../../../../assets/js/moment-with-locales.js"></script>

    
<script src="../../../../assets/js/algoliasearch.js"></script>

    <script>
      var algoliaClient = algoliasearch('9NRAR8EFQK', '27ad12d7095621830a22fc3883f0658c');
      var algoliaIndex = algoliaClient.initIndex('dev-hexo');
    </script>


    </body>
</html>
